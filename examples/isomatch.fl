load (DIR^"lib/signatures.fl");
load (DIR^"lib/utils.fl");

//==============================================================================
//
// ...
//
//==============================================================================

//  ::(formal#(actual list) list)->(formal#actual list)
let lineup = flatmap (curry zip # both md_expand_vector md_expand_vectors);
//  ::(formal#actual list)->(formal list)->(actual list)
let raise = map # subst;
//  ::(formal#actual list)->(actual list)->(formal list)
let lower = map # rev_subst;
//  ::(a->b)->(formal#actual list)->(formal#actual list)->(a#a list)->(b#b list)
let promote f ns hs = curry zip # both (f ns) (f hs) # unzip;

// Turns a subst. of formals into one over actuals.
let formalize fa_n fa_h = promote raise (lineup fa_n) (lineup fa_h);

// Turns a subst. of actuals into one over formals.
let actualize fa_n fa_h = promote lower (lineup fa_n) (lineup fa_h);

//------------------------------------------------------------------------------

// For every pair '(x,y) in s', checks 'assoc x s == y' and 'rev_assoc y s == x'.
let subst_verify s = all (\(u,t). all (\(x,y). (u == x) <==> (t == y)) s) s;

// For every pair '(x,y) in s', computes '(x, subst s y)'.
let subst_update s = map (second (subst s));

// Right-join two substitutions.
let subst_extend s u = subst_update s u @ s;

// Flatten a list of substitutions and checks if the result is coherent.
let subst_merge ss = let s = flat ss in subst_verify s => SOME s | NONE;

//------------------------------------------------------------------------------

// Labelled pexlif annotated with its adjacencies.
lettype ann =
        ANN
            {pex::pexlif}
            {lbl::string}
            {adj::string list}
;

let _ann_pex  (ANN p _ _) = p;
let _ann_lbl  (ANN _ l _) = l;
let _ann_adj  (ANN _ _ a) = a;
let
    Pann (ANN p l as) =
        sprintf "%s(%s):%S" (_pex_name p) l as
;
install_print_function Pann;

// Basic idea: label each leaf node with its wires (pushing substitutions downwards)
// and then check which are shared.
let
    annotate_pexlif pex =
        let
            extend sub fa =
                let
                    go sub []          = sub
                /\  go sub ((f,a):fas) = go () fas
                in
                go sub (lineup fa)
        in
        let
            annotate sub inst pex =
                val (PINST name leaf inps outs ints body) = pex in
                0
        in
        0
;

//==============================================================================
// Fin.